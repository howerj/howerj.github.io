<p>% FORTH(1)
% Richard Howe
% November 2016</p>

<h1>NAME</h1>

<p>forth - a forth interpreter</p>

<h1>SYNOPSIS</h1>

<p><strong>forth</strong> [<strong>-s</strong> file] [<strong>-e</strong> string] [<strong>-l</strong> file] [<strong>-m</strong> size] [<strong>-VthvL</strong>] [<strong>-</strong>] [<strong>files</strong>]</p>

<h1>DESCRIPTION</h1>

<p>A Forth interpreter built around a library, libforth, that implements a
complete Forth interpreter.</p>

<p>This interpreter is available at <a href="https://github.com/howerj/libforth">here</a>.</p>

<h1>OPTIONS</h1>

<p>Command line switches must be given before any files, unless that switch takes
a file as an argument.</p>

<ul>
<li>-s file</li>
</ul>

<p>This saves the working memory of the Forth interpreter to a file,
which can later be loaded with the "-l" option. If a core file has been
invalidated this will not be saved, invalidation occurs when an unrecoverable
error has been detected that would prevent any recovery or meaningful
execution with the current image.</p>

<ul>
<li>-e string</li>
</ul>

<p>Evaluate a Forth string passed in as an argument.</p>

<ul>
<li>-t</li>
</ul>

<p>After all the files have been read from and any core files have been loaded
this will make the Forth interpreter read from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a>, the core file will be
saved after <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a> has been read from and there is no more work to do, if
the "-d" or "-s" flags have been specified.</p>

<ul>
<li>-h</li>
</ul>

<p>Print out a short help message and exit unsuccessfully.</p>

<ul>
<li>-v</li>
</ul>

<p>Turn verbose mode on, more information will be printed out, to <a href="https://en.wikipedia.org/wiki/Standard_streams">stderr</a>, about
what is happening in the interpreter. Usually the interpreter is as silent as
possible.</p>

<ul>
<li>-m size</li>
</ul>

<p>Specify the virtual machines memory size in kilobytes, overriding the default
memory size. This is mutually exclusive with "-l".</p>

<ul>
<li>-l file</li>
</ul>

<p>This option loads a forth core file generated from the "-d" option of a
previous run. This core file is not portable and must be generated on the same
platform as it was generated. It can only be specified once per run of the
interpreter.</p>

<ul>
<li>'-'</li>
</ul>

<p>Stop processing any more command line options and treat all arguments after
this as files to be executed, if there are any.</p>

<ul>
<li>-V </li>
</ul>

<p>Print version and interpreter information and exit successfully.</p>

<ul>
<li>-L</li>
</ul>

<p>If the line editing library is compiled into the executable, which is a compile
time option, then when reading from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a> this will use a <a href="https://github.com/howerj/libline">line editor</a>
to read in a line at a time. This option implies <em>-t</em>.</p>

<ul>
<li>file...</li>
</ul>

<p>If a file, or list of files, is given, read from them one after another
and execute them. The dictionary and any stored Forth blocks will persist, as
will values on the stack. </p>

<p>If no files are given to execute <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a> will be read from.</p>

<h2>EXAMPLES</h2>

<pre><code>./forth
</code></pre>

<p>Execute any commands given from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a></p>

<pre><code>./forth -t file1.4th file2.4th
</code></pre>

<p>Execute file "file1.4th", then "file2.4th", then read from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a></p>

<pre><code>./forth file1.4th
</code></pre>

<p>Execute file "file1.4th".</p>

<pre><code>./forth -s file1.4th
</code></pre>

<p>Execute file "file1.4th", the produce a "forth.core" save file.</p>

<pre><code>./forth -s -l forth.core
</code></pre>

<p>Load a "forth.core" file, read from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a> and execute any commands given,
then dump the new core file to "forth.core".</p>

<p>The interpreter returns zero on success and non zero on failure.</p>

<h1>LICENSE</h1>

<p>The Forth interpreter and the library that implements it are released under the
<a href="https://opensource.org/licenses/MIT">MIT</a> license. Copyright (c) Richard Howe, 2016.</p>

<h1>EXIT STATUS</h1>

<p>This program will return a non-zero value on failure, and zero on success.</p>

<h1>SEE ALSO</h1>

<p>libforth(3)</p>

<h1>BUGS</h1>

<p>If you find a bug, or would like to request a new feature, please Email me at:</p>

<pre><code>    howe.r.j.89 [ at ] gmail . com
</code></pre>

<p>The interpreter has not been battle hardened yet so there is likely behavior
that is non-standard (for no reason) or just outright incorrect.</p>

<h1>MANUAL</h1>

<p>This small <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> interpreter is based on a de-obfuscated entrant
into the <a href="http://ioccc.org/winners.html">IOCCC</a> by <em>buzzard</em>. The entry described a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a>
like language which this derives from. You can use this library to
evaluate <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> strings or as an embeddable interpreter. Work
would need to be done to get useful information after doing those
evaluations, but the library works quite well.</p>

<p><em>main.c</em> is simply a wrapper around one the functions that implements
a simple <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>.</p>

<p>This project implements a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> interpreter library which can be embedded
in other projects, it is incredibly minimalistic, but usable. To build the
project a <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> compiler is needed, and a copy of <a href="https://en.wikipedia.org/wiki/Make_%28software%29">Make</a>, type:</p>

<pre><code>make help
</code></pre>

<p>For a list of build options. By running:</p>

<pre><code>make run
</code></pre>

<p>Will build the interpreter and run it, it will then read from <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a>.</p>

<p>To build the documentation other programs may be needed, such as <a href="http://pandoc.org/">pandoc</a> and
the <a href="https://daringfireball.net/projects/markdown/">markdown script</a>, but these steps are optional.</p>

<p><a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> is an odd language that has a loyal following groups, but it
is admittedly not the most practical of language as it lacks nearly everything
the modern programmer wants in a language; safety, garbage collection,
modularity and clarity. It is however possible to implement a fully working
interpreter in a one to two kilobytes of assembly, those kilobytes can make a
functional and interactive programming environment, giving a high ratio of utility
memory used.</p>

<p>From the <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Wikipedia</a> article we can neatly summarize the language:</p>

<pre><code>    "Forth is an imperative stack-based computer programming language 
    and programming environment. 

    Language features include structured programming, reflection (the
    ability to modify the program structure during program execution), 
    concatenative programming (functions are composed with juxtaposition) 
    and extensibility (the programmer can create new commands).

    ...

    A procedural programming language without type checking, Forth features
    both interactive execution of commands (making it suitable as a shell
    for systems that lack a more formal operating system) and the ability 
    to compile sequences of commands for later execution."
</code></pre>

<p>Given the nature of the <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> language it does not make for a terribly good
embeddable scripting language, but it is simple to implement and can be fun
to use. This interpreter is based off a previous <a href="http://ioccc.org/winners.html">IOCCC</a> in a file called
<a href="http://www.ioccc.org/1992/buzzard.2.c">buzzard.2.c</a>, it is a descendant of that file.</p>

<p>Before using and understanding this library/interpreter it is useful to checkout
more literature on <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> such as <a href="http://thinking-forth.sourceforge.net/">Thinking Forth</a> by Leo Brodie for a
philosophy of the language, <a href="http://www.forth.com/starting-forth/">Starting Forth</a> (same Author), <a href="https://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/">Jonesforth</a>
which is a specific implementation of the language in x86 assembly and
<a href="https://www.gnu.org/software/gforth/">Gforth</a>, a more modern and portable implementation of the language.</p>

<p>It is important to realize that <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> is really more a philosophy and
collection of ideas than a specific reference implementation or standard.
It has been said that an intermediate <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> user is one who has implemented
a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> interpreter, something which cannot be said about other languages
nor is possible given their complexity. </p>

<p>The saying "if you have seen one Forth implementation, you have seen one Forth 
implementation" applies, nearly every single <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> implementation has its 
own idea of how to go about things despite standardization efforts - in keeping 
with this, this library has its own idiosyncrasies.</p>

<p>This implementation, written in <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>, can be thought of as a hybrid between a
fairly dumb stack based virtual machine with instructions such as "pop two
values off the stack, add them, and push the result" and a small
interpreter/compiler for the virtual machine. This simple kernel is then used
to build a more compliant and usable <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> implementation by defining 
words that build upon those provided by the base system.</p>

<h2>Other documentation</h2>

<p>Apart from this file there are other sources of information about the
project:</p>

<p>As can the code, which is small enough to be comprehensible:</p>

<ul>
<li><a href="libforth.c">libforth.c</a> (contains the core interpreter)</li>
<li><a href="libforth.h">libforth.h</a> (contains the API documentation)</li>
</ul>

<p>And the forth startup code:</p>

<ul>
<li><a href="forth.fth">forth.fth</a></li>
</ul>

<p>The startup code is well commented and shows how the core interpreter is
extended to a more function <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> environment.</p>

<p>The source file <a href="libforth.c">libforth.c</a> can be converted to a more readable webpage by
first converting the source to <a href="https://daringfireball.net/projects/markdown/">markdown</a> with <a href="convert">convert</a> script, the converting
that to HTML in the usual fashion</p>

<h2>Using the interpreter</h2>

<p><em>main.c</em> simple calls the function <em>main_forth()</em> in <em>libforth.c</em>, this function
initializes a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> environment and puts the user in a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> where you
can issue commands and define words. See the manual pages for list of command
line options and library calls. All commands are given using 
<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a> (or RPN), </p>

<p>So:</p>

<pre><code>    2+(2*4)
</code></pre>

<p>Becomes:</p>

<pre><code>    4 2 * 2 +
</code></pre>

<p>And brackets are no longer needed. Numbers of pushed on to the variable
stack automatically and commands (such as '*' and '+') take their operands
off the stack and push the result. Juggling variables on the stack becomes
easier over time. To pop a value from the stack and print it there is the
'.' word.</p>

<p>So:</p>

<pre><code>    2 2 + .
</code></pre>

<p>Prints:</p>

<pre><code>    4
</code></pre>

<p>The simplicity of the language allows for a small interpreter, the
loop looks something like this:</p>

<pre><code>    1) Read in a space delimited Forth WORD.
    2) Is this WORD in the dictionary?
       FOUND)      Are we in IMMEDIATE mode?
                   IMMEDIATE-MODE) Execute WORD.
                                   goto 1;
                   COMPILE-MODE)   Compile WORD into the dictionary.
                                   goto 1;
       NOT-FOUND)  Is this actually a number?
                   YES) Are we in IMMEDIATE mode?
                        IMMEDIATE-MODE) Push Number onto the stack.
                                        goto 1;
                        COMPILE-MODE)   Compile a literal number.
                                        goto 1;
                   NO)  Error! Handle error
                        goto 1;
</code></pre>

<p>Given that we are reading in <em>space delimited words</em> if follows that the
above expression:</p>

<pre><code>    2 2 + .
</code></pre>

<p>Would not work if we did:</p>

<pre><code>    2 2+ .
</code></pre>

<p>Or:</p>

<pre><code>    2 2 +.
</code></pre>

<p>As "2+" and "+." would be parsed as words, which may or may not be defined
and if they are do not have the behavior that we want. This is more apparent
when we do any kind of string handling.</p>

<h2>A Forth Word</h2>

<p>The Forth execution model uses <a href="https://en.wikipedia.org/wiki/Threaded_code">Threaded Code</a>, the layout of a word
header follows from this.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> word is defined in the dictionary and has a particular format that
varies between implementations. A dictionary is simply a linked list of
<a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> words, the dictionary is usually contiguous and can only grow. The
format for our <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> words is as follows:</p>

<p>Briefly:</p>

<ul>
<li>Word Header:</li>
<li>field &lt;0 = Word Name (the name is stored before the main header)</li>
<li>field 0  = Previous Word</li>
<li>field 1  = Code Word (bits 0 - 7) | Hidden Flag (bit 8) | Word Name Offset (bit 9 - 15) </li>
<li>field 3  = Code Word or First Data field Entry</li>
<li>field 4+ = Data Field</li>
</ul>

<p>And in more detail:</p>

<pre><code>    .------------------------------------------------.----------------.
    |                   Word Header                  |   Word Body    |
    .---------------.-----.------.-------------------.----------------.
    | NAME ...      | PWD | MISC | CODE WORD or DATA | DATA ...       |
    .---------------.-----.------.-------------------.----------------.

    ____
    NAME        = The name, or the textual representation, of a Forth
                  word, it is a variable length field that is ASCII NUL
                  terminated, the MISC field has an offset that points
                  to the begining of this field if taken off the PWD
                  position (not value). The offset is in machine words,
                  not characters.
    ___
    PWD         = A pointer to the previously declared word.
    ____
    MISC        = A complex field that can contains a CODE WORD, a
                  "hide" bit and the offset from the PWD field to the
                  beginning of NAME
    _________    ____
    CODE WORD or DATA = This will be RUN if the following DATA is a pointer
                  to the CODE WORDs of previously defined words. But it
                  could be any CODE WORD.
    ____
    DATA        = This could be anything, but it is most likely to be
                  a list of pointers to CODE WORDs of previously defined
                  words if this optional DATA field is present.
</code></pre>

<p>All fields are aligned on the <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> virtual machines word boundaries.</p>

<p>The MISC field is laid out as so:</p>

<pre><code>    .-------------------------------------------------------------------------------.
    | &lt;- Least Significant Bit                              Most Significant Bit -&gt; |
    .-------------------------------------------------------------------------------.
    |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
    .-------------------------------------------------------------------------------.
    |            CODE WORD             | HD |          NAME OFFSET                  |
    .-------------------------------------------------------------------------------.
    _________
    CODE WORD    = Bits 0-6 are a code word, this code word is always run
                   reguardless of whether we are in compiling or command
                   mode
    __
    HD           = Bit 7 is the Hide Bit, if this is true then when
                   compiling or executing words the word will be hidden from the 
                   search.
    ___________
    NAME OFFSET  = Bits 8 to 15 are the offset to the words name. To find the 
                   beginning of the words name we take this value away from
                   position of this words PWD header. This value is in
                   machine words, and so the beginning of the NAME must be aligned 
                   to the virtual machine words boundaries and not character, or byte, 
                   aligned. The length of this field, and the size of the input buffer, 
                   limit the maximum size of a word.
</code></pre>

<p>Depending on the virtual machine word size, or cell size, there may be more
bits above bit '15', the most significant bit, in the MISC field. These bits
are not used and should be set to zero.</p>

<p>And the dictionary looks like this:</p>

<pre><code>   [ Special 'fake' word ]
              .
             /|\
              |
   .-------.-----.----------------------.
   | NAME  | PWD | Rest of the word ... |
   .-------.-----.----------------------.
              .
             /|\
              |
            ~~~~~
     The rest of the dictionary
            ~~~~~
              |
   .-------.-----.----------------------.
   | NAME  | PWD | Rest of the word ... |
   .-------.-----.----------------------.
              .
             /|\
              |
   .-------.-----.----------------------.
   | NAME  | PWD | Rest of the word ... |
   .-------.-----.----------------------.
              .
             /|\
              |
   [ Previous Word Register ]
</code></pre>

<p>Searching of the dictionary starts from the <em>Previous Word Register</em> and ends
at a special 'fake' word.</p>

<p>Defining words adds them to the dictionary, we can defined words with the ':'
words like this:</p>

<pre><code>    : two-times 2 * ;
</code></pre>

<p>Which defined the word "two-times", a word that takes a value from the stack,
multiplies it by two and pushes the results back onto the stack.</p>

<p>The word ':' performs multiple actions; it is an immediate word that reads in the
next space delimited word from the input stream and creates a header for that
word. It also switches the interpreter into compile mode, compiling words will
be compiled into that word definition instead of being executed, immediate words
are executed as normal. ';' is also an immediate word, it compiles a special
word exit into the dictionary which returns from a word call and switches the
interpreter back into command mode. This type of behavior is typical of
<a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> implementations.</p>

<h2>Memory Map and Special Registers</h2>

<p>The way this interpreter works is that is emulates an idealized machine, one
built for executing <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> directly. As such it has to make compromises and
treats certain sectors of memory as being special, as shown below (numbers are
given in <em>hexadecimal</em> and are multiples of the virtual machines word-size
which is either 16, 32 or 64 bit depending on compile time options. </p>

<p>Where the dictionary ends and the variable and return stacks begin depends on 
how much memory was allocated to the interpreter (with a minimum of 2048 
words), the default is 32768 words, and the following diagram assumes this:</p>

<pre><code>    .-----------------------------------------------.
    | 0-3F      | 40-7BFF       |7C00-7DFF|7E00-7FFF|
    .-----------------------------------------------.
    | Registers | Dictionary... | V stack | R stack |
    .-----------------------------------------------.

    V stack = The Variable Stack
    R stack = The Return Stack
</code></pre>

<p>Each may be further divided into special sections:</p>

<h3>Registers</h3>

<p>At the beginning of the Forth virtual machine there is a section used for
registers, modifying them arbitrary can cause undefined behavior to occur which
will most likely cause the virtual machine to be terminated.</p>

<pre><code>NAME          LOCATION        DESCRIPTION
              DECIMAL  HEX
              0-1      0-1    Unused
              2-5      2-5    Push integer word
DIC           6        6      Dictionary pointer
RSTK          7        7      Return stack pointer
STATE         8        8      Interpreter state; compile or command mode
BASE          9        9      Base conversion variable
PWD           10       A      Pointer to last defined word 
SOURCE_ID     11       B      Input source selector (-1 = string input, 
                              0 = file input)
SIN           12       C      String input pointer
SIDX          13       D      String input index  (index into SIN)
SLEN          14       E      String input length (length of SIN)
START_ADDR    15       F      Pointer to start of VM
FIN           16       10     File input pointer
FOUT          17       11     File output pointer 
STDIN         18       12     File pointer to stdin, if available
STDOUT        19       13     File pointer to stdout, if available
STDERR        20       14     File pointer to stderr, if available
ARGC          21       15     Count of arguments passed to program,
                              if available
ARGV          22       16     An array of pointers to NUL terminated
                              ASCII strings, if available, of ARGC
                              length
DEBUG         23       17     Turn debugging on/off if enabled
INVALID       24       18     If non zero, this interpreter is invalid 
TOP           25       19     Stored version of top of stack
INSTRUCTION   26       1A     Stored version of instruction pointer
STACK_SIZE    27       1B     Size of the variable stack
ERROR_HANDLER 28       1C     Action to take on error
THROW         29       1D     Used for throw/catch
SCRATCH_X     30       1E     Fixed scratch variable for the user
SCRATCH_Y     31       1F     Fixed scratch variable for the user
</code></pre>

<h3>Dictionary</h3>

<p>Apart from the constraints that the dictionary begins after where the 
registers are and before where V stack is there are no set demarcations
for each region, although currently the defined word region ends before
0x200 leaving room between that and 0x7BFF for user defined words.</p>

<pre><code>    .----------------------------------------------------------------.
    | 40-???            | ???-???          | ???-7BFF                |
    .----------------------------------------------------------------.
    | Special read word | Interpreter word | Defined word ...        |
    .----------------------------------------------------------------.

    Special read word = A word called on entrance to the interpreter, 
                        it calls itself recursively (as a tail call). This
                        word cannot be 'found', it does not have a name.
    Interpreter word  = Any named (not 'invisible' ones) interpreter word 
                        gets put here.
    Defined word      = A list of words that have been defined with ':'
</code></pre>

<h2>Glossary of Forth words</h2>

<p>Each word is also given with its effect on the variable stack, any other effects
are documented (including the effects on other stacks). Each entry looks like
this:</p>

<ul>
<li>word ( y -- z )</li>
</ul>

<p>Where 'word' is the word being described, the contents between the parenthesis
describe the stack effects, this word expects one number to be one the stack,
'y', and returns a number to the stack 'z'.</p>

<h3>Internal words</h3>

<p>There are three types of words.</p>

<h4>'Invisible' words</h4>

<p>These invisible words have no name but are used to implement the Forth. They
are all <em>immediate</em> words.</p>

<ul>
<li>push ( -- x)</li>
</ul>

<p>Push the next value in the instruction stream onto the variable stack, advancing
the instruction stream.</p>

<ul>
<li>compile ( -- )</li>
</ul>

<p>Compile a pointer to the next instruction stream value into the dictionary.</p>

<ul>
<li>run ( -- )</li>
</ul>

<p>Save the current instruction stream pointer onto the return stack and set
the pointer instruction stream pointer to point to value after <em>run</em>.</p>

<h4>Immediate words</h4>

<p>These words are named and are <em>immediate</em> words.</p>

<ul>
<li>':'           ( -- )</li>
</ul>

<p>Read in a new word from the input stream and compile it into the dictionary.</p>

<ul>
<li>'immediate'   ( -- )</li>
</ul>

<p>Make the previously declared word immediate. Unlike in most Forth
implementations this is used after the words name is given not after the
final ';' has been reached.</p>

<p>So:</p>

<pre><code>    : word immediate ... ;
</code></pre>

<p>Instead of:</p>

<pre><code>    : word ... ; immediate
</code></pre>

<ul>
<li>'\'           ( -- )</li>
</ul>

<p>A comment, ignore everything until the end of the line.</p>

<h4>Compiling words</h4>

<ul>
<li>'read'        ( -- )</li>
</ul>

<p><em>read</em> is a complex word that implements most of the input interpreter,
it reads in a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> <em>word</em> (up to 31 characters), if this <em>word</em> is in
the <em>dictionary</em> it will either execute the word if we are in <em>command mode</em>
or compile a pointer to the executable section of the word if in <em>compile
mode</em>. If this <em>word</em> is not in the <em>dictionary</em> it is checked if it is a
number, if it is then in <em>command mode</em> we push this value onto the <em>variable
stack</em>, if in <em>compile mode</em> then we compile a <em>literal</em> into the <em>dictionary</em>.
If it is none of these we print an error message and attempt to read in a
new word.</p>

<ul>
<li>'@'           ( address -- x )</li>
</ul>

<p>Pop an address and push the value at that address onto the stack.</p>

<ul>
<li>'!'           ( x address -- )</li>
</ul>

<p>Given an address and a value, store that value at that address.</p>

<ul>
<li>'c@'          ( char-address -- char )</li>
</ul>

<p>Pop a character address and push the character value at that address onto the
stack. Note that this access is not checked for being within range of the
virtual machines memory, but it is still relative to the start address of
virtual machine memory. </p>

<ul>
<li>'c!'          ( char char-address -- )</li>
</ul>

<p>Given a character address, store a character value at that address, like 'c@'
the address is relative to the virtual machines starting address.</p>

<ul>
<li>'-'           ( x y -- z )</li>
</ul>

<p>Pop two values, subtract 'y' from 'x' and push the result onto the stack.</p>

<ul>
<li>'+'           ( x y -- z )</li>
</ul>

<p>Pop two values, add 'y' to 'x' and push the result onto the stack.</p>

<ul>
<li>'and'         ( x y -- z )</li>
</ul>

<p>Pop two values, compute the bitwise 'AND' of them and push the result on to
the stack.</p>

<ul>
<li>'or'          ( x y -- z )</li>
</ul>

<p>Pop two values, compute the bitwise 'OR' of them and push the result on to
the stack.</p>

<ul>
<li>'xor'         ( x y -- z )</li>
</ul>

<p>Pop two values, compute the bitwise 'XOR' of them and push the result on to
the stack.</p>

<ul>
<li>'invert'      ( x y -- z )</li>
</ul>

<p>Perform a bitwise negation on the top of the stack.</p>

<ul>
<li>'lshift'      ( x y -- z )</li>
</ul>

<p>Pop two values, compute 'y' shifted by 'x' places to the left and push
the result on to the stack.</p>

<ul>
<li>'rshift'      ( x y -- z )</li>
</ul>

<p>Pop two values, compute 'y' shifted by 'x' places to the right and push
the result on to the stack.</p>

<ul>
<li>'*'          ( x y -- z )</li>
</ul>

<p>Pop two values, multiply them and push the result onto the stack.</p>

<ul>
<li>'/'           ( x y -- z )</li>
</ul>

<p>Pop two values, divide 'x' by 'y' and push the result onto the stack. If 'y'
is zero and error message is printed and 'x' and 'y' will remain on the
stack, but execution will continue on as normal.</p>

<ul>
<li>'u\&lt;'         ( x y -- z )</li>
</ul>

<p>Pop two unsigned values, compare them (y &lt; x) and push the result onto the
stack, the comparison will be unsigned.</p>

<ul>
<li>'u>'         ( x y -- z )</li>
</ul>

<p>Pop two values, compare them (y > x) and push the result onto the stack. The
comparison will be unsigned.</p>

<ul>
<li>'exit'        ( -- )</li>
</ul>

<p>Pop the return stack and set the instruction stream pointer to that
value.</p>

<ul>
<li>'key'         ( -- char )</li>
</ul>

<p>Get a value from the input and put it onto the stack.</p>

<ul>
<li>'_emit'      ( char -- status )</li>
</ul>

<p>Put a character to the output stream returning a success value.</p>

<ul>
<li>'r>'          ( -- x )</li>
</ul>

<p>Pop a value from the return stack and push it to the variable stack.</p>

<ul>
<li>'>r'          ( x -- )</li>
</ul>

<p>Pop a value from the variable stack and push it to the return stack.</p>

<ul>
<li>'branch'           ( -- )</li>
</ul>

<p>Jump unconditionally to the destination next in the instruction stream.</p>

<ul>
<li>'?branch'          ( bool -- )</li>
</ul>

<p>Pop a value from the variable stack, if it is zero the jump to the
destination next in the instruction stream, otherwise skip over it.</p>

<ul>
<li>'pnum'           ( x -- status )</li>
</ul>

<p>Pop a value from the variable stack and print it to the output either
as a ASCII decimal or hexadecimal value depending on the BASE register. A
return status is pushed onto the stack, greater or equal to zero is a success,
negative is a failure. Failure can occur because of an invalid base in the BASE
register, or because the output could not be written to.</p>

<ul>
<li>'''           ( -- )</li>
</ul>

<p>Push the next value in the instruction stream onto the variable stack
and advance the instruction stream pointer over it.</p>

<ul>
<li>','           ( x -- )</li>
</ul>

<p>Write a value into the dictionary, advancing the dictionary pointer.</p>

<ul>
<li>'='           ( x y -- z )</li>
</ul>

<p>Pop two values, perform a test for equality and push the result.</p>

<ul>
<li>'swap'        ( x y -- y z )</li>
</ul>

<p>Swap two values on the stack.</p>

<ul>
<li>'dup'         ( x -- x x )</li>
</ul>

<p>Duplicate a value on the stack.</p>

<ul>
<li>'drop'        ( x -- )</li>
</ul>

<p>Drop a value.</p>

<ul>
<li>'over'        ( x y -- x y x )</li>
</ul>

<p>Duplicate the value that is next on the stack.</p>

<ul>
<li>'find'        ( -- execution-token )</li>
</ul>

<p>Find a word in the dictionary pushing a pointer to that word onto the
variable stack.</p>

<ul>
<li>'depth'       ( -- depth )</li>
</ul>

<p>Push the current stack depth onto the stack, the value is the depth of the
stack before the depth value was pushed onto the variable stack.</p>

<ul>
<li>'sp@'         ( -- addr )</li>
</ul>

<p>Push the address of the stack pointer onto the stack, before <strong>sp@</strong> was 
executed:</p>

<pre><code>1 2 sp@ . . .
</code></pre>

<p>Prints:</p>

<pre><code>2 2 1
</code></pre>

<ul>
<li>'sp!'         ( addr -- )</li>
</ul>

<p>Set the address of the stack pointer.</p>

<ul>
<li>'clock'       ( -- x )</li>
</ul>

<p>Push the difference between the startup time and now, in milliseconds. This
can be used for timing and implementing sleep functionality, the counter
will not increase the interpreter is blocking and waiting for input, although
this is implementation dependent.</p>

<ul>
<li>'evaluator'   ( c-addr u 0 | file-id 0 1 -- x )</li>
</ul>

<p>This word is a primitive used to implement 'evaluate' and 'include-file', it
takes a boolean to decide whether it will read from a file (1) or a string (0),
and then takes either a forth string, or a <strong>file-id</strong>.</p>

<ul>
<li>'system'      ( c-addr u -- status )</li>
</ul>

<p>Execute a command with the systems command interpreter.</p>

<h5>File Access Words</h5>

<p>The following compiling words are part of the File Access Word set, a few of
the fields need explaining in the stack comments. "file-id" refers to a
previously opened file as returned by "open-file", "ior" refers to a return
status provided by the file operations. "fam" is a file access method, </p>

<ul>
<li>'close-file'  ( file-id -- ior )</li>
</ul>

<p>Close an already opened file.</p>

<ul>
<li>'open-file'   ( c-addr u fam -- file-id ior )</li>
</ul>

<p>Open a file, given a Forth string (the 'c-addr' and the 'u' arguments), and a
file access method, which is defined within "forth.fth". Possible file access
methods are "w/o", "r/w" and "r/o" for read only, read-write and write only
respectively.</p>

<ul>
<li>'delete-file' ( c-addr u -- ior )</li>
</ul>

<p>Delete a file on the file system given a Forth string.</p>

<ul>
<li>'read-file'   ( c-addr u file-id -- ior )</li>
</ul>

<p>Read in 'u' characters into 'c-addr' given a file identifier.</p>

<ul>
<li>'write-file'  ( c-addr u file-id -- ior )</li>
</ul>

<p>Write 'u' characters from 'c-addr' to a given file identifier.</p>

<ul>
<li>'file-position'   ( file-id -- ud ior )</li>
</ul>

<p>Get the file position offset from the beginning of the file given a file
identifier.</p>

<ul>
<li>'reposition-file' ( ud file-id -- ior )</li>
</ul>

<p>Reposition a files offset relative to the beginning of the file given a file
identifier.</p>

<ul>
<li>flush-file ( file-id -- ior )</li>
</ul>

<p>Attempt to flush any buffered information written to a file.</p>

<ul>
<li>rename-file ( c-addr1 u1 c-addr2 u2 -- ior )</li>
</ul>

<p>Rename a file on the file system named by the first string ('c-addr1' and 'u1')
to the second string ('c-addr2' and 'u2').</p>

<h3>Defined words</h3>

<p>Defined words are ones which have been created with the ':' word, some words
get defined before the user has a chance to define their own to make their
life easier.</p>

<ul>
<li>'state'       ( -- addr )</li>
</ul>

<p>Push the address of the register that controls the interpreter state onto
the stack, this value can be written to put the interpreter into compile
or command modes. </p>

<ul>
<li>';'           ( -- )</li>
</ul>

<p>Write 'exit' into the dictionary and switch back into command mode.</p>

<ul>
<li>'base'         ( -- addr )</li>
</ul>

<p>This pushes the address of a variable used for input and output conversion of
numbers, this address can be written to and read, valid numbers to write are 0
and 2 to 36 (<em>not</em> 1).</p>

<ul>
<li>'pwd'         ( -- pointer )</li>
</ul>

<p>Pushes a pointer to the previously define word onto the stack.</p>

<ul>
<li>'h'           ( -- pointer )</li>
</ul>

<p>Push a pointer to the dictionary pointer register.</p>

<ul>
<li>'r'           ( -- pointer )</li>
</ul>

<p>Push a pointer to the register pointer register.</p>

<ul>
<li>'here'        ( -- dictionary-pointer )</li>
</ul>

<p>Push the current dictionary pointer (equivalent to "h @").</p>

<ul>
<li>'['          ( -- )</li>
</ul>

<p>Immediately switch into command mode.</p>

<ul>
<li>']'          ( -- )</li>
</ul>

<p>Switch into compile mode</p>

<ul>
<li>'>mark'      ( -- location )</li>
</ul>

<p>Write zero into the head of the dictionary and advance the dictionary pointer,
push a address to the zero written into the dictionary. This is usually used
after in a word definition that changes the control flow, after a branch for
example.</p>

<ul>
<li>':noname'     ( -- execution-token )</li>
</ul>

<p>This creates a word header for a word without a name and switches to compile
mode, the usual ';' finishes the definition. It pushes a execution token onto
the stack that can be written into the dictionary and run, or executed directly.</p>

<ul>
<li>'if'          ( bool -- )</li>
</ul>

<p>Begin an if-else-then statement. If the top of stack is true then we
execute all between the if and a corresponding 'else' or 'then', otherwise
we skip over it.</p>

<p>Abstract Examples:</p>

<pre><code>    : word ... bool if do-stuff ... else do-other-stuff ... then ... ;

    : word ... bool if do-stuff ... then ... ;
</code></pre>

<p>and a concrete examples:</p>

<pre><code>    : test-word if 2 2 + . cr else 3 3 * . cr ;
    0 test-word
    4             # prints 4
    1 test-word
    9             # prints 9
</code></pre>

<p>Is a simple and contrived example.</p>

<ul>
<li>'else'        ( -- )</li>
</ul>

<p>See 'if'.</p>

<ul>
<li>'then'        ( -- )</li>
</ul>

<p>See 'if'.</p>

<ul>
<li>'begin'       ( -- )</li>
</ul>

<p>This marks the beginning of a loop.</p>

<ul>
<li>'until'       ( bool -- )</li>
</ul>

<p>Loop back to the corresponding 'begin' if the top of the stack is zero, continue
on otherwise.</p>

<ul>
<li>"')'"         ( -- char )</li>
</ul>

<p>Push the number representing the ')' character onto the stack.</p>

<ul>
<li>'tab'         ( -- )</li>
</ul>

<p>Print a tab.</p>

<ul>
<li>'cr'          ( -- )</li>
</ul>

<p>Prints a newline.</p>

<ul>
<li>'('           ( -- )</li>
</ul>

<p>This will read the input stream until encountering a ')' character, it
is used for comments.</p>

<ul>
<li>'allot'       ( amount -- )</li>
</ul>

<p>Allocate a number of cells in the dictionary.</p>

<ul>
<li>'tuck'        ( x y -- y x y )</li>
</ul>

<p>The stack comment documents this word entirely.</p>

<ul>
<li>'nip'         ( x y -- y )</li>
</ul>

<p>The stack comment documents this word entirely.</p>

<ul>
<li>'rot'         ( x y z -- z x y )</li>
</ul>

<p>The stack comment documents this word entirely. This word rotates three items
on the variable stack.</p>

<ul>
<li>'-rot'        ( x y z -- y z x )</li>
</ul>

<p>The stack comment documents this word entirely. This word rotates three items
on the variable stack, in the opposite direction of "rot".</p>

<ul>
<li>'emit'        ( x -- )</li>
</ul>

<p>Write a single character out to the output stream.</p>

<h2>Library of Forth words</h2>

<p>The file <a href="forth.fth">forth.fth</a> contains many defined words, however those words are
documented within that file and so as to avoid duplication will not be
mentioned here. This file is <em>not</em> loaded automatically, and so should be run
like this:</p>

<p>Unix:</p>

<pre><code>    ./forth -t forth.fth
</code></pre>

<p>Windows</p>

<pre><code>forth.exe -t forth.fth
</code></pre>

<h2>Glossary of Forth terminology</h2>

<ul>
<li>Word vs Machine-Word</li>
</ul>

<p>Usually in computing a 'word' refers to the natural length of integer in a
machine, the term 'machine word' is used to invoke this specific meaning, 
a word in <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> is more analogous to a function, but there
are different types of Forth words; <em>immediate</em> and <em>compiling</em> words,
<em>internal</em> and <em>defined</em> words and finally <em>visible</em> and <em>invisible</em> words.</p>

<p>The distinction between a machine word and a Forth word
can lead to some confusion.</p>

<ul>
<li><em>The</em> dictionary</li>
</ul>

<p>There is only one dictionary in a normal <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> implementation, it is a
data structure that can only grow in size (or at least it can in this
implementation) and holds all of the defined words.</p>

<ul>
<li><em>The</em> stack</li>
</ul>

<p>When we referring to a stack, or the stack, we refer to the variable stack
unless otherwise stated (such as the return stack). The variable, or the
stack, holds the result of recent operations such as addition or subtraction.</p>

<ul>
<li>The return stack</li>
</ul>

<p>Forth implementations are two (or more) stack machines. The second stack
is the return stack which holds the usual function call return values as 
well as temporary variables. </p>

<ul>
<li>Defined Words</li>
</ul>

<p>A defined word is one that is not implement directly by the interpreter but
has been create with the ':' word. It can be an <em>immediate</em> word, but does
not have to be.</p>

<ul>
<li>Compile mode</li>
</ul>

<p>In this mode we <em>compile</em> words unless those words are <em>immediate</em> words,
if the are then we immediately execute them.</p>

<ul>
<li>Command mode</li>
</ul>

<p>In this mode, regardless of whether we are in <em>command</em> or <em>compile</em> mode
we execute words or push them on to the stack.</p>

<ul>
<li>A block.</li>
</ul>

<p>A <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a> block is primitive way of managing persistent storage and this
version of block interface is more primitive than most. A block is a
contiguous range of bytes, usually 1024 of them as in this instance, and
they can be written or read from disk. Flushing of dirty blocks is not
performed in this implementation and must be done 'manually'.</p>

<h2>Porting this interpreter</h2>

<p>The interpreter code is written in <a href="https://en.wikipedia.org/wiki/C99">C99</a>, and is written to be portable, however
porting it to embedded platforms that lack a C standard library (which is most
of them) would mean replacing the most of the C standard library functions used, 
and implementing a new I/O mechanism for reading, printing and block storage.</p>

<p>The interpreter has been tested on the following platforms:</p>

<ul>
<li>Linux x86-64 with,
<ul>
<li>Debian Jessie (8.x)</li>
<li>GCC version 4.9.2</li>
</ul></li>
<li>Windows 7 x86-64 (not recently)</li>
<li>Linux ARM 32-bit Little Endian (not recently)</li>
<li>OSX Sierra 10.12.1 (tested by Rikard Lang).</li>
</ul>

<p>And the different virtual machine word size options (32 and 64 bit machine
words) have been tested. There is no reason it should not also work on 16-bit
platforms.</p>

<p>libforth is also available as a <a href="http://tldp.org/LDP/lkmpg/2.6/html/">Linux Kernel Module</a>, on a branch of libforth,
see <a href="https://github.com/howerj/libforth/tree/linux-kernel-module">https://github.com/howerj/libforth/tree/linux-kernel-module</a>. This is
module is very experimental, and it is quite possible that it will make your
system unstable.</p>

<h2>Standards compliance</h2>

<p>This Forth interpreter is in no way compliant with any of the standards
relating to Forth, such as <a href="http://lars.nocrew.org/dpans/dpans.htm">ANS Forth</a>, or previous Forth standardization
efforts. However attempts to support words and behavior typical of these
standards are made.</p>

<p>Some important deviations are:</p>

<ul>
<li>immediate</li>
</ul>

<p>In most Forths the "immediate" word goes after a words definition instead of
inside it like this:</p>

<pre><code>    : word ... ; immediate
</code></pre>

<p>Instead this interpreter does it:</p>

<pre><code>    : word immediate ... ;
</code></pre>

<p>This behavior will not be changed for the foreseeable future, although it is
the biggest difference. This is due to how the internals of the interpreter
work.</p>

<ul>
<li>recursion and definition hiding</li>
</ul>

<p>A word can be called immediately before the terminating semi-colon has been
reached, in the middle of a word definition. This makes the recurse keyword
redundant but means using a previous definition of a word with the same name
more difficult (but can be done). This might be a candidate for behavior that
should be made more compliant.</p>

<ul>
<li>ok</li>
</ul>

<p>'ok' is not printed after a successful command execution , this is for two 
reasons, firstly because of limitations in the implementation, and secondly 
there is no reason for cluttering up the output window with this. The
implementation should be silent by default.</p>

<h2>Bugs</h2>

<p>As mentioned in the standards compliance section, this Forth does things in a
non-standard way. Apart from that:</p>

<ul>
<li>Passing invalid pointers to instructions like <strong>open-file</strong> or <strong>system</strong> can
cause undefined behavior (your program will most likely crash). There is no
simple way to handle this (apart from not doing it).</li>
<li>The core interpreter does not currently make use of the throw and catch
mechanism when handling certain errors (like division by zero), in effect there
are two error handlers. These mechanisms need unifying.</li>
</ul>

<h2>To-Do</h2>

<ul>
<li>Port this to a micro controller, and a Linux kernel module device
pointer to the forth object, a pointer to the stack and the stack depth.</li>
<li>A few environment variables could be used to specify start up files for the
interpreter and user specific startup files.</li>
<li>Add save-core, number, parse, load-core, more-core to the
virtual machine.</li>
<li>Signal handling should be added, so the Forth program can handle them.</li>
<li>Add loading in a Forth image from a memory structure, this will need
to be in a portable Format.</li>
<li>Error handling could be improved - the latest word definition should be
erased if an error occurs before the terminating ';'</li>
<li>For a Forth only related "To-Do" list see the end of the file <a href="forth.fth">forth.fth</a>.</li>
<li>A compiler for the virtual machine itself should be made, as a separate
program. This could be used to make a more advanced read-evaluate loop.</li>
<li>Core files are currently not portable across machines of different words
sizes or endianess, which needs addressing.</li>
<li>Character addressing should be used throughout the interpreter, instead of
cell addressing and conversion to/from character addresses. Real address 
could also be used, but this would make core files non-portable.</li>
<li>The unit tests in <a href="unit.c">unit.c</a> could be integrated with the main program.</li>
<li><p>Due to the way Windows opens stdin, stdout, and stderr, there are problems
reading in binary files, this can be remedied quite easily with some code
that executes before <strong>main_forth</strong> is called.</p>

<h1>include "libforth.h"</h1>

<h1>ifdef _WIN32</h1>

<h1>include <io.h></h1>

<h1>include <fcntl.h></h1>

<h1>include <stdio.h></h1>

<h1>endif</h1>

<p>int main(int argc, char **argv)
{</p>

<h1>ifdef _WIN32</h1>

<pre><code>_setmode(_fileno(stdin), _O_BINARY);
_setmode(_fileno(stdout), _O_BINARY);
</code></pre>

<h1>endif</h1>

<pre><code>return main_forth(argc, argv);
</code></pre>

<p>}</p></li>
</ul>

<h2>Notes</h2>

<ul>
<li>The compilation should result in a small executable, and when statically
linked against <a href="https://www.musl-libc.org/">musl</a> under Linux (x86-84), the stripped executable is around
50kb in size.</li>
<li>It is quite possible to make Forth programs that corrupt memory that they
should, this is not a design flaw in this interpreter but more part of the
Forth philosophy. If you want memory safety (and most of the time you should) 
you should use a different language, or implementation. </li>
</ul>

<p><style type="text/css">body{margin:40px auto;max-width:850px;line-height:1.6;font-size:16px;color:#444;padding:0 10px}h1,h2,h3{line-height:1.2}</style></p>
